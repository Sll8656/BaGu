# 得物

- [ ] JVM的架构，具体阐述一下各个部分的功能？

> **类加载**子系统，运行时**数据区**（内存结构），执行引擎(JIT,GC,解释器)，本地方法接口，本地方法库。

- [ ] Zset的底层如何实现？

> 哈希（元素值->分数）+ 跳表（元素值排序）

- [ ] Mysql隔离机制有哪些？怎么实现的？可串行化是怎么避免的三个事务问题？

> 1.4种隔离级别
>
> 2.实现方法：mvcc + 锁
>
> 3.避免脏读：看不到未提交的数据;   不可重复读和幻读：事务开始后，因为有锁，所以别的事务不能修改。

- [ ] Spring的三级缓存知道吗？

> 1级：存放初始化完毕的单例bean， 2级：存放实例化但是没完全初始化的早期引用， 3级：存放ObjectFactory接口的实现类
>
> 过程：创建一个 bean，从1-> 2->3依次找。如果1,2都没，则通过ObjectFactory创建bean的早期引用放入2级，初始化完成后放入1级。
>
> 解决循环依赖：先创建A，通过三级缓存暴露A的早期引用，发现A依赖B，创建B并使用早期的A，避免了无限循环。
>
> 三级缓存解决apo动态代理：ObjectFactory创建早期的代理对象而不是原始对象，这样在还未初始化时就将代理对象暴露出来。

- [ ] 抛开Spring，讲讲反射和动态代理？那三种代理模式怎么实现的？

> 反射：允许程序在运行时检查和修改自身的结构，反射是java提供的获取类信息的手段。
>
> 动态代理：jdk和cglib，jdk快一点但是需要接口

- [ ] 讲讲线程池？为什么用线程池？

> 维护一定数量的线程来执行提交的任务。
>
> 优点：能够有效地控制并发执行线程的数量，减少创建和销毁线程的开销，提升系统的稳定性和响应速度。

- [ ] 集合里面的arraylist和linkedlist的区别是什么？有何优缺点？

> arraylist是数组：内存利用率高，查询效率高
>
> llinkedlist是链表：修改效率高，扩容效率高

- [ ] 介绍一下计网里面的tcp和udp协议

> tcp特点：面向连接、可靠传输、数据流控制、数据有序性、拥塞控制。速度慢但是稳
>
> udp特点：无连接、不可靠传输、低开销、面向报文。速度快但是不稳

- [ ] 介绍一下http和https的区别？为什么https安全？

> http：80端口、明文无加密、不验证身份
>
> https：443端口、通过SSl/TSL协议加密数据、验证身份

- [ ] Mysql有很大的数据量怎么办？怎么分表分库？

> 数据量大会出现查询速度变慢、写入延迟增加等问题。可通过分库分表来改善性能。
>
> 分库就是拆成不同数据库，分表就是拆成不同的表。有水平分库分表（横着切），垂直分库分表（竖着切）
>
> 挑战：事务管理、跨表查询、数据迁移和扩展、全局唯一ID	

- [ ] Redis的基本数据类型？Redis的持久化呢？有何优缺点？

> string，Hash，List，set，zset， bitmap，geo，hyperloglog
>
> rdb优点：恢复速度快、写磁盘不频繁；缺点：可能丢失、生成快照要fork消耗资源
>
> aof：优点：数据安全、可读；缺点：文件较大、恢复速度慢
>
> 混合持久化：4.0引入，出发持久化先生成rdb快照，同时增量aof日志写入文件。

- [ ] B+树了解吗？底层呢？为什么这么用？

> 每个结点对应磁盘的一页（高效磁盘读写）、只有叶字结点存数据（查找路径长度稳定）、中间节点不存数据（良好的缓存命中率）、高度低（IO次数少）、叶字结点用双向链表连接（便于范围查询）

- [ ] sql慢查询优化

>在sql语句前加上explain命令，能够看到索引、读取顺序、数据过滤情况。
>
>创建合适的索引；优化查询语句；优化数据库配置；优化事务

- [ ] 索引什么情况下会失效

> 使用函数表达式、隐式类型转换、like匹配且%在前、使用`!=`操作符、or的任意一边不用、不符合最左前缀

- [ ] HTTPS 加密过程

> 客户端发起https请求、服务器响应并发送证书、客户端验证证书、客户端生成会话密钥、客户端使用服务器公钥加密会话密钥、服务器使用私钥解钥、使用会话密钥进行对称加密通信、数据传输完成、连接关闭。

- [ ] git rebase和 merge 的区别

> A上：`git merge B`，将B合并到A中，并保留各个分支的记录，B分支不变
>
> A上：`git rebase B` ，将A的根节点接到了B最新的结点后面，然后这一整条作为A，B分支没有变
>
> A上：`git rebase -i <commit-id>`，进入交互式编辑器，列出从id之后的所有提交，可以在编辑器中修改提交历史

```
原分支:
C1 - C2 - C3 (A)
	\
	 C4 - C5(B)
	 
-----在A上 git merge B  会变成
  C1 - C2 - C3 ---- M (A)
   \            /
    C4 - C5 (B)
    
-----在A上 git rebase B 会变成
         C1' - C2' - C3' (A)
        /
 C4 - C5 (B)
```

* [ ] 线程和进程区别

> 定义：进程是独立程序的实例；线程是进程的一个执行单元
>
> 内存空间：进程之间独立，同一个进程的线程共享该进程的内存空间。
>
> 资源开销：进程要分配空间、加载资源、初始化；线程只要分配少量内存。
>
> 执行调度：进程用时间片轮转，优先级，需要保存和恢复上下文；线程不需要切换内存空间，开销小。
>
> 通信方式：进程有管道、mq、共享内存、套接字；线程有共享的内存空间，通过共享变量、条件变量、信号量同步。
>
> 安全性：进程是独立的，稳定和安全性较高；线程由于共享内存，可能造成雪崩。

- [ ] Redis单线程模型

> Redis的所有操作都是在一个线程中依次执行。
>
> 优点：避免上下文切换开销、避免处理多线程下复杂的同步问题、避免用到锁

- [ ] Redis 主从复制流程

> 节点发送psync（psync带有参数offset和replid），尝试增量（判断replid是否一致、查看offset是否被覆盖），不一致或者覆盖则增量失败，发起全量同步。
>
> 全量同步：主收到psync后，生成rdb，发给从节点同时继续写缓冲区。从节点收到后加载该rdb，加载完rdb，从节点更新缓冲区中的增量数据。
>
> 增量同步：主节点获取psync命令的offset，将offset之后的数据发送给从节点。

- [ ] 布隆过滤器底层实现

>布隆过滤器通过使用多个哈希函数和位数组，在空间上进行了非常高效的优化，适用于需要快速判断元素存在性的场景。
>
>插入元素：使用k个哈希函数，得到k个idx，将这些idx置为1。
>
>查询元素：使用k个哈希函数，得到k个idx，去查询，**全为1**说明存在。

- [ ] 用Redis ZSet 实现排行榜先用分数再用时间排序怎么实现?

> 构造**综合排序键**，`综合排序键 = 分数 * 1,000,000 + (最大时间戳 - 时间戳)`这样子能保证高分在前，分数相同则时间新的在前。

- [ ] 如何设计秒杀场景处理高并发以及超卖现象?

> 解决高并发：用mq、令牌桶或漏桶、异步处理
>
> 解决超卖：Redis分布式锁、**库存预减**（Redis操作是原子的能防止超卖，先在Redis中减，再异步处理db的更新）、CAS控制库存（确保基于最新的库存数进行扣减）。
>
> 防止重复下单：幂等性设计（用户ID）、限购策略
>
> 降级和熔断：流量过大时，对非核心业务进行降级。系统到达瓶颈直接熔断。

- [ ] 如果对热点数据设置过期时间，活动结束后删除可能会阻塞主线程，怎么解决?

> 异步删除机制：将删除操作提交到线程中中处理，而不是主线程
>
> 分批删除：将删除任务分成小批次进行，避免一次性大量删除导致阻塞主线程
>
> 分布式：将数据分散在不同的节点上，减轻单个节点的删除压力。

- [ ] 如果用 Hash 存商品 ID 和商品数量，当大量请求打过来的时候，商品数量可能变负，还可以用什么数据结构?

> 使用Redis原子操作：Redis的Hash结构提供了原子操作，或者写lua脚本
>
> 消息队列异步处理：将高并发的库存请求放进mq，然后消费者在mq中逐个扣减
>
> 使用乐观锁：更新的时候使用version字段或者cas机制，确保更新库存时库存的值是准确的

- [ ] Mysql怎么实现数据恢复

> 1.二进制日志恢复：mysql的binary log记录了db中所有修改数据的sql，通过这些sql可以实现恢复
>
> 2.快照备份：数据库的快照备份指全量备份，用mysqldump工具导出数据库或者表数据。
>
> 3.物理数据恢复：关闭mysql服务，将数据分拣拷贝到安全位置，恢复时拷贝回原位置即可。

- [ ] Redolog是怎么保证事务不丢失，写入内存时宕机了怎么办

> redolog步骤：事务进行的更改记录到内存的redo log buffer中，事务提交之前，将log buffer文件刷盘，刷盘成功标记事务为提交。
>
> WAL保证事务不丢失，WAL ：在事务的修改被标记为“提交”前，相关的日志记录必须已经写入到磁盘上。这意味着即使事务在内存中的数据还没来得及更新，只要相关的日志记录已经安全地写入磁盘，这个事务就可以被认为是持久化的。这样，即使数据库突然宕机或遇到故障，这些事务也不会丢失。
>
> 内存宕机了，表示log buffer文件还未刷盘就丢失了，所以丢失的事务都是没提交的。重启后，mysql会重做已经刷了盘的事务，在内存中丢失的事务反正也没提交，意味着没有对数据库造成改变，所以丢失了也没影响。

- [ ] Redis怎么实现可重入锁

> 锁的标识可以使用线程ID或其他唯一标识符，然后使用setnx或set命令尝试设置一个锁，key不存在则操作成功，key存在就看value是不是与唯一标识符匹配。如果匹配，增加一个计数器来实现重入，这个计数器可以存在另一个key中或者value的一部分。
>
> 使用lua脚本进行原子操作：在检查锁的持有者和在计数的过程中需要保证原子性，故使用lua脚本保证检查和incr操作不会被打断。释放锁同理，decr操作和删除操作（计数为0则删除锁）也应该使用lua脚本。

- [ ] 什么是io多路复用

> IO多路复用（Input/Output Multiplexing）是一种在单个线程中管理多个输入/输出通道的技术。它允许一个线程同时监听多个输入（例如网络套接字、文件描述符等），并在有数据可读或可写时进行相应的处理，而不需要为每个通道创建一个独立的线程。



# 美团

- [ ] ThreadLocal的用途，原理

> 核心功能：创建线程局部变量
>
> 用途：保持数据的线程隔离、用户会话信息存储、事务管理、性能优化（避免了同步操作）
>
> 原理：
>
> 1. 存储结构：使用ThreadLocalMap，每个线程持有自己的ThreadLocalMap，key是ThreadLocal对象本身，value是数据
>
> 2. 数据访问：线程首次调用TL的get或set方法，线程会从其Thread对象中检索ThreadLocalMap，没有则创建

- [ ] 四种引用跟作用

>强：沿着GCRoot能找到，不会被回收
>
>软：SoftReference，内存不够会回收；适合用于实现内存敏感的缓存。
>
>弱：WeakReference，只要进行了gc，就回收；适用于不实现任何强引用的，声明周期短的对象。比如图片缓存，元数据。
>
>虚：配合引用队列，不能通过虚引用来获取对象实例。唯一的用途是在这个对象被回收时收到一个系统通知，主要用来跟踪对象被垃圾回收的活动，通常用于实现比较精细的内存管理场景。

- [ ] 为什么用canal，canal原理

> Canal用于基于MySQL的增量日志解析，提供增量数据订阅和消费。
>
> 1. 数据同步：Canal能实时地将数据变更从MySQL同步到其他数据库，比如ES，Redis
> 2. 数据库变更日志解析：提供对数据库变更的实时监控，让开发者在不直接访问db的情况下获取变更数据
> 3. 降低数据库压力：通过异步处理数据变更，减少对生产数据库的直接查询和访问压力
>
> 原理：
>
> 1. 连接到MysQl，模拟MySQL slave的角色，连接到MySQL master
> 2. 读取Binlog：通过MySQL的复制协议，Canal从MySQL master读取binlog
> 3. 解析Binlog：解析binlog中的数据变更信息，将这些信息转换成统一的格式（如json，sql等）
> 4. 数据投递：将解析后的数据按照设定的方式投递到不同的下游系统，例如mq

- [ ] 事务ACID怎么实现的

>原子性：通过undolog记录反向操作，如果事务失败了，就能够通过反向操作撤回
>
>一致性：数据库通过强制执行数据完整性约束（如外键、主键等）来保证一致性。
>
>隔离性：其他事务不会看到该事务的中间状态。通过锁定对象（如行锁、表锁）来防止多个事务同时更新同一数据。一些数据库系统使用MVCC来允许读取操作和写入操作同时发生而不互相阻塞，通过保持数据的多个版本来管理不同事务的视图。
>
>持久性：WAL，事务提交之前，会先将redolog中的log buffer刷盘，刷盘成功后才提交；冗余存储：使用备份数据保证硬件故障也能恢复。

> ==关于一致性==：
>
> “一致”是指数据库中的数据是正确的，不存在矛盾。事务的一致性是指事务执行前后，数据都是正确的，不存在矛盾。如果执行后数据是矛盾的，事务就会回滚到执行前的状态（执行前是一致的）。
>
> 满足一致性的例子
>
>     学生表中的学号是唯一的。
>     账户的余额减少了，账单中要有对应的扣款记录，且减少的金额和账单的扣款金额一致。
>     一篇文章浏览量为100次，则浏览记录表有该文章的100条浏览记录。
>     发布文章的用户ID是100，则用户表中存在ID为100的用户。
>
> 不满足一致性的例子
>
>     学生表中有重复的学号。
>     转账成功了，但是付款的人余额没扣，或者收款的人余额没有增加。
>     付款多次，只扣款1次（或者付款1次，扣款多次）。
>     发布文章的用户ID是100，但用户表中没有ID=100的用户。
>     文章的发布时间是空的。

- [ ] 事务两阶段提交

>事务的两阶段提交是一种用于在**分布式数据库系统中**保证事务的**原子性**的协议。
>
>第一阶段：准备阶段
>
>1. **事务协调者开始**：事务的发起者，也称为协调者，发送一个准备消息给所有参与事务的节点，要求它们准备提交事务。
>2. **参与者准备：**每个参与者将事务中的所有操作处理到一致的点，并记录必要的信息到日志中（保证后续可以完成或撤销事务），然后锁定事务涉及的资源以阻止其他操作干扰。
>3. **投票**：参与者向协调者发送投票消息。投票可以是“同意”表明它们可以安全地提交事务，或是“反对”表明无法提交事务并已回滚（中止事务）。
>
>第二阶段：提交/回滚阶段
>
>1. **所有同意**：如果协调者从所有参与者收到“同意”投票，它将发送一个“提交”（commit）命令给所有参与者。
>
>2. **任何反对**：如果任何参与者投了“反对”或协调者未能从所有参与者那里收到响应，它将发送一个“回滚”（abort）命令给所有已投“同意”的参与者。
>
>3. **执行提交或回滚**：参与者根据协调者的命令执行提交或回滚操作，并将结果记录在日志中。一旦提交或回滚完成，参与者释放所有锁定的资源，并通知协调者操作已完成。
>
>4. **完成事务**：协调者收到所有参与者的完成确认后，事务正式结束。

- [ ] MVCC原理

>**1. 数据版本控制**
>
>​	**版本创建**：在MVCC中，每当数据被修改时，系统并不直接覆盖旧数据，而是创建一个新的版本。这意味着每个数据项可以有多个版本，每个版本都有一个唯一的时间戳或版本号。
>
>​	**事务时间戳**：每个事务在开始时获取一个唯一的时间戳。读操作会看到该时间戳之前的最新数据版本，而写操作则会创建带有新时间戳的数据版本。
>
>**2. 读操作**
>
>​	**非阻塞性读**：读事务不需要锁定数据。它通过查找与其时间戳兼容的数据版本（通常是最接近但不晚于事务时间戳的版本）来执行读取操作。这允许读取操作访问旧的数据版本，而新的数据版本由其他事务修改并提交。
>
>​	**一致性视图**：每个事务看到的是一个一致的数据库快照，这个快照是在事务开始时创建的。这保证了在事务执行期间即使数据被其他事务修改，读取操作也不会受到影响。
>
>**3. 写操作**
>
>​	**版本链**：每个数据项的不同版本通过版本链相连。新版本的数据项会被添加到链的头部。写事务创建数据的新版本，并在提交时将其与旧版本链接。
>
>​	**冲突检测**：写事务在提交时检查是否有其他已提交的事务修改了相同的数据。如果检测到冲突（即另一个事务在当前事务读取数据后修改并提交了该数据），当前写事务可能需要回滚。
>
>**4. 垃圾收集**
>
>​	**版本清理**：随着时间的推移，一些旧的数据版本不再被任何事务需要。数据库系统会定期进行垃圾收集，删除这些不再需要的旧数据版本，以释放空间并保持系统效率。
>
>**MVCC 优点**
>
>​	**并发性能提升**：MVCC允许多个读者和写者同时对数据库进行操作，而不需相互等待。
>
>​	**读写分离**：读操作可以访问旧版本数据，而写操作生成新版本，因此读和写操作不会直接冲突。
>
>​	**避免死锁**：因为读操作通常不需要锁定资源，所以MVCC可以减少死锁的发生。
>
>**MVCC 缺点**
>
>​	**空间开销**：由于保持多个版本的数据，MVCC可能会增加存储空间的使用。
>
>​	**性能开销**：管理多个数据版本以及进行垃圾收集可能会增加系统的性能开销。

- [ ]  为什么用volatile关键字，能保证什么，volatile底层怎么实现的

> 保证可见性、有序性、不保证原子性
>
> |是屏障   ：   写  |   读
>
> - **对 volatile 变量进行写操作时，会在写操作后加一条 store 屏障指令，将工作内存中的共享变量刷新回主内存；**
> - **对 volatile 变量进行读操作时，会在读操作前加一条 load 屏障指令，从主内存中读取共享变量；**



- [ ] AOP在spring中怎么实现的，JDK跟CGLIB动态代理区别

> Spring AOP 提供了在方法执行的前后、方法抛出异常后以及方法调用前插入额外功能的能力。
>
> **1. JDK 动态代理**
>
> ​	JDK 动态代理是基于接口的代理技术。使用这种代理方式时，所有被代理的类都必须实现一个或多个接口。JDK 动态代理通过反射机制动态地创建代理对象，代理对象会实现目标对象的同一接口。
>
> **特点：**
>
> 1. 只能代理实现了接口的类。
>2. 创建了一个新的类，这个新类实现了目标类所实现的所有接口。
> 
>**2. CGLIB 动态代理**
> 
>​	CGLIB（Code Generation Library）是一个强大的高性能代码生成库，它可以在运行时扩展Java类与实现Java接口。它广泛用于许多AOP的框架中，以提供方法拦截操作。CGLIB代理包装了目标对象，因此被代理的对象不需要实现接口。
> 
>**特点：**
> 
>1. 可以代理没有实现接口的类。
> 2. 生成目标类的一个子类。通过扩展目标类，代理类可以拦截到父类（目标类）的所有方法调用。
>3. 性能通常比JDK动态代理略低，但不需要目标对象实现接口。
> 
>**Spring AOP的代理选择**：在Spring AOP中，默认情况下，如果目标对象实现了接口，则会使用JDK动态代理。如果目标对象没有实现接口，则使用CGLIB来创建代理。
> 
>**动态代理的实际应用**
> 
>​	这种动态代理机制允许Spring AOP无缝地将切面逻辑应用到Spring管理的bean上。例如，你可以定义一个事务管理切面，自动处理事务的开始和提交，或者定义一个日志切面来记录方法调用。
> 
>​	Spring通过这种方式允许开发者轻松地添加或删除跨越多个点的行为，比如日志、事务管理、安全等，而无需修改实际执行业务逻辑的代码。这样做提高了代码的可维护性和可重用性。
> 

- [ ] 一个list，用lambda表达式求出所有符合条件的学生总数

> ```java
> //lambda表达式：
> long count = students.stream().filter(student -> student.getAge() > 18).count();
> 
> //方法引用
> Student中：
> public boolean isOlderThan18() {
>     return this.age > 18;
> }
> long count = students.stream().filter(Student::isOlderThan18).count();
> ```

- [ ] 常见的垃圾回收器，CMS跟G1各自讲讲

>**CMS：**
>
>![image-20240403124623844](https://s2.loli.net/2024/09/18/UCe5NzDBY3Ec9pk.png)
>
>  **初始标记（Initial Mark）**：STW暂停，快速标记直接与 GC roots 相连的对象。
>
>  **并发标记（Concurrent Mark）**：在应用线程并行运行时，遍历堆中对象，标记所有存活的对象，不暂停应用线程。
>
>  **重新标记（Remark）**：STW 暂停，清理并发标记阶段因应用程序继续运行而遗漏的部分。
>
>  **并发清除（Concurrent Sweep）**：清除未标记的对象，回收内存，不暂停应用线程。
>
>
>
>**G1:**G1是一款非常优秀的垃圾收集器，不仅适合堆内存大的应用，同时也简化了调优的工作。通过主要的参数初始和最大堆空间、以及最大容忍的GC暂停目标，就能得到不错的性能；同时，我们也看到G1对内存空间的浪费较高，但通过**首先收集尽可能多的垃圾(Garbage First)**的设计原则，可以及时发现过期对象，从而让内存占用处于合理的水平。

- [ ] 介绍一下HashMap？链表采用头插还是尾插？多线程并发访问的情况下尾插有什么问题？除了数据覆盖呢？

>1.7之前使用头插，1.8开始使用尾插法。
>
>头插法问题：多个线程同时插入，可能会导致链表的环形结构，因为在更新链表头部的链接时，新节点和旧结点之间的链接可能被其他线程的操作打断。
>
>尾插法问题：减少头部的并发修改，降低了循环链表的风险，但是他也存在其他问题：
>
>1. 数据覆盖：两个线程同时尝试在一个同的链表中添加元素，一个线程的插入可能会覆盖另一个线程的操作
>2. 数据可见性：一个线程的HashMap的修改可能对其他线程不可见
>
>解决方案：使用ConcurrentHashMap

- [ ] ConcurrentHashMap如何保证线程安全的？什么情况下采用CAS+自旋？什么情况下采用synchronize？

> 1.7之前采用分段锁，每一段本质上是一个小的hash table。一个线程访问某个key的时候，只获取该段的锁。多个线程访问不同段的数据是可以同时进行的。同一段使用ReentrantLock进行同步。
>
> 1.8之后采用节点锁，只锁node。当链表较长时转化为红黑树，改进了高冲突环境下的性能。
>
> **CAS+自旋的情况：**处理**节点操作**时，比如节点的添加、删除等，如果预期的修改很小，会采用CAS
>
> **Synchronized：**在更新操作比较复杂，或者结点的结构更改时，ConcurrentHashMap使用锁来同步，这些操作可能涉及多个步骤，需要完整的原子性来保证。

- [ ] 如何判断一条SQL是否走了索引？除了explain呢？explain有哪些列？

> explain输出的主要列：`id（标识符）,table, possible_keys(可能用到的索引), key(实际用到的索引),key_len（使用的索引的长度）,rows（返回的行数）,filtered（返回结果的行数占读到的行数百分比）`
>
> 除了explain，使用`show index from table_name`可以查看该表的所有索引信息。

- [ ] undolog的数据结构是怎样的？

> 



# 招商银行

- [ ] Java堆内存和栈内存的区别

>访问：堆内存是所有线程共享的，在堆上分配的对象可以被程序中的任何线程访问；栈内存是线程私有的，每个线程都有自己的栈，用于处理方法调用和局部变量。
>
>管理：堆内存的管理由Java垃圾回收器负责，栈内存的分配和回收是自动进行的。一个方法被调用时，被推到栈顶，调用完就弹出。

- [ ] 里氏替换原则

> 如果S是T的子类，则引用类型为T的对象可以被类S的对象替换，替换后，程序的行为不能发生改变。
>
> ```java
> //基类
> @Data
> class Rectangle {
>     private int width;
>     private int height;
> }
> 
> //子类
> class Square extends Rectangle {
>     @Override
>     public void setWidth(int w) {
>         super.setWidth(w);
>         super.setHeight(w);
>     }
> 
>     @Override
>     public void setHeight(int h) {
>         super.setWidth(h);
>         super.setHeight(h);
>     }
> }
> //方法
> public static void increaseRectangleWidth(Rectangle rect) {
>     rect.setWidth(rect.getWidth() + 10);
> }
> ```
>
> 如果传入一个Rectangle，那确实没错。但是如果传入Square，就同时改变了长和宽。因此不遵循里氏替换原则

- [ ] Mysql联合索引的设计原则

> 核心：最左前缀匹配原则
>
> ```sql
> SELECT * FROM table WHERE A = 1 AND B = 2;  -- 有效利用索引(A, B, C)
> SELECT * FROM table WHERE A = 1;            -- 有效利用索引(A, B, C)
> SELECT * FROM table WHERE B = 2 AND C = 3;  -- 索引不会被使用，因为没有包含最左列A
> SELECT * FROM table WHERE A = 1 AND C = 3;  -- 索引部分被使用（只使用到A）
> ```
>
> 关键因素考虑：
>
> 1. 选择列的顺序：选择性高的列应该放在前面，这样能更快地缩小搜索范围
> 2. 尽量使用覆盖索引
> 3. 最左匹配原则

- [ ] 如何保证交易，订单等不会重复处理

> 1. 使用唯一事务ID：为每个交易或订单生成一个唯一的事务id，这个id可以**在业务流程开始时生成**，确保每次操作都有一个标识符。处理前先检查db或者缓存中是否存在该id的记录，如果存在，则拒绝处理或者忽略
> 2. 数据库约束：利用数据库的唯一性约束防止重复记录。例如在订单表中对订单号设置唯一索引。
> 3. 幂等性设计：每次操作前检查资源的当前状态，只有在特定状态下才执行操作。
> 4. mq和锁：使用mq时，每个消息只被消费一次，可以通过消息的确认和重试机制来处理失败的情况。在处理特定订单或者交易前，获取一个分布式锁。
