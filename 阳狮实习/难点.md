## 1、新增in的时候需要要上传文件，文件又需要in_id，产生矛盾

in表和kv表是1对多的关系，所以在kv表中设置一个in_id。但是在新增数据的时候，遇到一个难题。新增in表需要传入一个kv的模板然后进行解析。解析出来的数据需要一个in_id，但是此刻in还没创建，就发生了矛盾。

解决方案：写到一个service中，在inservice里，先生成一个uuid，然后解析文件，将解析出来的数据的in_id全部设置为这个uuid，然后将传入的inDTO的id设置为uuid。最后save，注意要加事务。

失败：如果将dto和文件一起当做参数传进来，没办法解析文件。



解决方法：同时使用@RequestParam，@RequestPart是可以的。其中RequestParam传入String，然后用ObjectMapper将String转成dto。 生成uuid -> 赋值给rfq的in_id ->赋值给in的id ->存储。注意加事务。



后来发现这个解决方案还是不行，还得用RequestBody

我发现解析excel 代码太长了， 在in新增的时候上传3个文件，如果放在一个接口中和dto一起传，这样不光业务代码特别长不好维护，其次用户点击save按钮可能要等待一会，体验不好。

我有一个新的方案： 在用户点击上传excel的时候，调用upload接口，会先存放进oss，然后再将解析的excel存进数据库中，**这个时候因为in的数据还没有生成，所以没有id**。于是使用oss的主键作为file_id，在in阶段加file_id，excel实体也加上file_id。这样in和excel的file_id相同，说明他们绑定同一个文件。再解析excel的时候，存放进数据库先不设置in_id，而是传出来一个file_id，最后点击save的时候，不仅将传出来这个file_id设置为in的file_id。还能用这个file_id去回表，在in已经保存后，拿主键和file_id回表，去excel表中找到数据并且更新in_id位in的主键。**但是点击save的时候要传入前边传出来的file_id，这怎么解决？**一开始说交给前端，后来发现用mq可以，upload的时候直接讲file_id传进队列，然后in这边监听队列，只要监听到了，就把mq中的file_id赋值给自己。

用户有可能上传完excel，然后不点save就退出了，这样之前保存的就是脏数据了。为了解决这个问题，在excel表中增加一个超时字段，设置好时间。再使用定时任务定期清理。如果用户点击save调用了in数据保存的接口，在这个业务中就把excel的超时字段改成null。这样就不会被定时任务清理了。







## 2、关联Excel中两个sheet的数据(detail -> sum_id)

EasyExcel的规则：必须先解析sheet1，再解析sheet2.并且只能按行 一行一行解析。

summary里面是A,B,C...,  然后对应detal里面A的1,2,3..，B的1,2,3....

所以说必须先解析完summary的A,B,C....存进sum表中。才能解析detal的A-1,2,3...  B-1,2,3...

要想关联上detal和summary，只能针对detail表进行处理。

思路：

按行解析detal， 解析到A,用一个变量记下来，然后再遇到B之前，将后面读到的1,2,3...全部都赋值给excelEntity中没有被注解@Property的Item字段。然后将这个东西直接赋值。实体类也有这个字段。在Bean转换的时候就会直接带上了。

```java
public void invoke(ProductionInQuotationDetailExcel productionInQuotationDetailExcel, AnalysisContext context) {
    if( !uset.contains(productionInQuotationDetailExcel.getItem())
    && !uset1.contains(productionInQuotationDetailExcel.getItem())) return;
    if(uset1.contains(productionInQuotationDetailExcel.getItem())) {
        sign = productionInQuotationDetailExcel.getItem();
        return;
    }
    productionInQuotationDetailExcel.setSumItem(sign);
    productionInQuotationDetailExcelList.add(productionInQuotationDetailExcel);
}
```

要想再关联上sum_id，就通过fileId + sumItem + type去确定唯一的sum条。然后赋值。这样就必须在for循环中执行sql了，因为sumItem是不停变动的!

## 3、mybatisFlex的Relation出现的问题

背景：prdIn 和 crvAfter通过mapping表连接。prdIn和crvAfter是 1对多关系。搞了个prdDto，dto中有一个
  字段是`List<crvAfter> crvAters;`  crvAfter里面有agencyName。
  Excel中prdIn里面agencyName字段是通过很多crvAfter的agencyName进行拼接得到的。
  我在类型转换的时候，发现不好处理这个agencyName字段，于是在dto中又加入了一个agencyName
  在拿到dto的时候，直接stream处理，遍历crvAters，拼接好后给agencyName赋值
 	这样就产生了一个问题：
  **如果1个prd关联了多个crv , 就会产生多条相同的数据。**
  为什么呢？
  因为VO没有agencyName这个字段，看似相同，实则不相同！
  如果给VO再加上agencyName这个字段，会发现第一条的agencyName是遇见小面1，第二条是遇见小面2
  为什么会出现这种情况？
  因为联表查询查到的数据是 :

```java
prd_id   crv_id    agency_name
    1       1       遇见小面1
    1       2       遇见小面2
    1       3       遇见小面3
```

  在dto中的`List<crvAfter> crvAters`使用了`@RelationOneToMany`注解
  这样MyBatis就会把这三条数据变成

```json
data: [
  "prdId" : '1'
  "crvAfters" : [
    {
      "crvId" = 1,
      "agencyName" = 遇见小面1
    }, 
    {
      "crvId" = 2,
      "agencyName" = 遇见小面2
    }, 
    {
      "crvId" = 3,
      "agencyName" = 遇见小面3
    }, 
  ]
]
```


也就是说聚合了一个 prdId  对应的  三个  crvAfter

 现在如果加上了agencyName，就无法进行聚合了！

 因为agencyName没有relation这种对应，就会出现下面这种情况：

```json
data: [
  { 
   "prdId" : 1,
   "agencyName": "遇见小面1",
   "crvAfters" : ... 
  },
  {
   "prdId" : 1,
   "agencyName": "遇见小面2",
   "crvAfters" : ... 
  },
  {
   "prdId" : 1,
   "agencyName": "遇见小面3",
   "crvAfters" : ... 
  }
]
```

所以要去掉这个agencyName！才能成功聚合
总结：  我的理解是  除了标记了`@relation`的`List<CrvAfter>`这个字段 ，mybatis直接groupy by了剩下的所有字段 , 因此剩下的字段只要不一样，就算不同的数据。这里就是agencyName不一样了，所以算作多个。



## 4.列表下拉值关联表出现相同字段的处理

在productionIn的列表下拉值中，需要进行联表查询，但是联表完之后，会出现相同的字段。这个时候数据库就会报错，sql语句根本执行不了。

