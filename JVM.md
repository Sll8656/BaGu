

[TOC]



![image-20240402142038017](https://s2.loli.net/2024/09/18/v1ABH5UmGh9bQDu.png)



# 内存结构

![image-20240402143736861](https://s2.loli.net/2024/09/18/6bBqMlgORptS3PE.png)

---

## 什么是程序计数器

程序计数器：线程私有的，内部保存的字节码的行号。用于记录正在执行的字节码指令的地址。

当线程运行一半时被别的线程抢夺了cpu，再次回来的时候，需要通过pc来找到原来的位置。

---

## 说一说Java堆

* Java中堆是线程共享的区域，主要用来保存对线实例、数组等，当堆中没有内存空间可分配给实例，再也无法扩展时，就会抛出OOM异常
* 组成：年轻代+老年代
  * 年轻代分为Eden区和两个大小相同的survivor区
  * 老年代主要保存生命周期长的对象，一般是一些老的对象
* Jdk1.7和1.8的区别
  * 1.7中永久代在堆中，存储的类信息、静态变量、常量、编译后的代码
  * 1.8移除了永久代，变成了**本地内存中**的元空间，防止内存溢出

---

## 什么是虚拟机栈？

* 每个线程运行时所需要的内存，称为虚拟机栈，先进后出
* 每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存
* 每个线程只有一个活动栈帧，对应着当前正在执行的那个方法

---

## 垃圾回收是否设计栈内存？

垃圾回收主要指堆内存，当栈帧弹栈以后，内存会释放

---

## 栈内存分配越大越好吗？

不是，默认栈内存通常为1024k。机器总内存是有限的，栈帧过大会导致线程数变少。

---

## 方法内的局部变量是否线程安全？

* 如果方法内局部变量没有逃离方法的作用范围，它是线程安全的
* 如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全 

---

## 什么情况下导致栈内存溢出：

* 栈帧过多导致栈内存溢出，典型问题：递归调用
* 栈帧过大导致栈内存溢出

---

## 堆和栈的区别是什么？

* 栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储java对象和数组的。堆会GC垃圾回收，而栈不会
* 栈内存是线程私有的，而堆内存是线程共有的
* 两者异常错误不同，栈是Stack over flow，堆是oom

---

## 解释一下方法区

答：

* 方法区是各个**线程共享的内存区域**
* 主要存储类的信息、运行时常量池
* 虚拟机启动的时候创建，关闭虚拟机时释放
* 如果方法区中的内存无法满足分配请求，会抛出OOM:Metaspace

![image-20240402154616865](https://s2.loli.net/2024/09/18/3BXxVuRojDOCt8E.png)



---

## 介绍一下运行时常量池

* 常量池：可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息

* 当类被加载的时候，他的常量池信息会放入**运行时常量池**，并把里面的**符号地址变为真实地址**

---

## 说一说直接内存

* 直接内存：不属于JVM中的内存结构，不由JVM进行管理，是虚拟机的系统内存

* 常见于NIO操作时，用于数据缓冲区，他的读写性能高，但是分配回收成本也高，并且不受JVM内存回收管理



# 类加载器



![image-20240402165516753](https://s2.loli.net/2024/09/18/R8E9BscrKwgY1bf.png)

---

## 什么是类加载器？

JVM只会运行二进制文件，类加载器的作用就是将**字节码文件加载到JVM中**，从而让Java程序能够启动起来

---

## 类加载器有哪些？

* 启动类加载器：加载`JAVA_HOME/jre/lib目录下的库`
* 扩展类加载器：主要加载JAVA_HOME/jre/lib/ext目录中的类
* 应用类加载器：用于加载classPath下的类
* 自定义类加载器：自定义类继承ClassLoader，实现自定义类加载规则

---

## 什么是双亲委派模型？

答：加载某一个类，先委托上一级的加载器进行加载，如果上级加载器也有上级，则会继续向上委托，如果该类委托上级没有被加载，子加载器尝试加载该类。

---

## JVM为什么采用双亲委派机制

答：

* 1）通过双亲委派机制可以避免某一类被重复加载，当父类已经加载后则无序重复加载，保证唯一性
* 2）为了安全，保证类库API不会被修改

![image-20240402171802435](https://s2.loli.net/2024/09/18/fWI5y3dlqJTK2Ew.png)

---

## 说一下类装载的执行过程？

![image-20240403090236840](https://s2.loli.net/2024/09/18/scNDgWpmnCLJ5Za.png)

**加载**：先把类的**二进制数据流读入到运行时数据区**，在**元空间中存储类的信息**，在堆**中开辟空间存储==类==的class对象**，方便后期创建对象去使用

```
[类信息] <--- 堆中的 Class 对象（指向类信息） <-- 实例对象（通过 Class 对象获取元信息）
```

**验证：**验证类是否符合JVM规范，安全性检查

**准备：**为类变量分配（`（static变量 && final修饰 && 基本类型）` ||` 字符串常量`）内存并设置类变量初始值

**解析：**把类中的符号引用转化为直接引用

* 符号引用与内存布局无关，直接引用则与内存布局密切相关。

* 方法中调用了其他方法，方法名可以理解为符号引用，而直接引用就是指针直接指向方法

**初始化：**对类的静态变量和静态代码块初始化操作

* 初始化一个类的时候，如果父类尚未初始化，则优先初始化父类
* 如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行

**使用：**

* 调用静态类成员信息（比如：静态字段、静态方法）
* 使用new关键字为其创建对象实例

---

## 说一下类装载的执行过程？

* 加载：查找和导入class文件
* 验证：保证加载类的准确性和安全性
* 准备：为类变量分配内存，并设置变量初始值
* 解析：把类中的符号引用转化为直接引用
* 初始化：对类的静态变量，静态代码块执行初始化操作
* 使用：JVM开始从入口方法开始执行用户的程序代码
* 卸载：当用户程序代码执行完毕后，JVM便开始销毁创建的Class对象

---

# 垃圾回收

对象什么时候可以被垃圾回收器回收？

如果一个对象或多个对象没有任何引用指向它，那么这个对象现在就是垃圾。

定位什么是垃圾，有两种方式来确定，第一个是`引用计数法`，第二个是`可达性分析法`。

* 引用计数法：一个对象被引用了一次，在当前的对象头上递增一次引用计数，如果这个对象的引用次数为0，代表这个对象可回收

  缺点：当对象间出现了**循环引用**，就会失效

* 可达性分析算法：从GC Root出发往下搜索，没有被扫描到的对象表示可以回收

可以作为GC Root的对象：

* 虚拟机栈（栈帧中的本地变量）中引用的对象

  * ```java
    //Demo可以作为GCRoot
    public static void main(String[] args) {
        Demo demo = new Demo();
        demo = null;
    }
    ```

* 方法区中类静态属性引用的对象

  * ```java
    public static Demo a;
    public static void main(String[] args) {
        Demo b = new Demo();
        //a是某个静态变量，指向了内存中的某一块数据，因此a也可以作为GC Root
        b.a = new Demo();
        b = null;
    }
    ```

* 方法区中常量引用的对象

  * ```java
    public static final Demo a = new Demo();
    public static void main(String[] args) {
        Demo demo = new Demo();
        demo = null;
    }
    ```

* 本地方法栈中JNI（即Native方法）引用的对象

---

JVM垃圾回收算法有哪些？

* 标记清除算法
* 复制算法
* 标记整理算法

1、标记清除算法：将垃圾回收分为两个阶段，分别是标记和清除

​	1）根据可达性分析算法得出的垃圾进行标记

​	2）对这些标记为可回收的内容进行垃圾回收

![image-20240403094719425](https://s2.loli.net/2024/09/18/QB8pcfG1EsLyKrC.png)

优点：标记和清除速度较快

缺点：碎片化严重，内存不连贯

2、标记整理算法：

![image-20240403094904469](https://s2.loli.net/2024/09/18/v9e5I2al14LhDJK.png)

优点：解决了内存碎片化的问题

缺点：多了一步移动对象的位置，效率变低

3、复制算法

![image-20240403095023993](https://s2.loli.net/2024/09/18/9YLdEWG8mbVx5Q7.png)

优点：

* 在垃圾对象多的情况下，效率较高
* 清理后，无内存碎片

缺点：需要分配2块内存空间，同一时刻只能使用一半

---

**分代GC：**

堆内存 = 年轻代 + 老年代。 年轻代 = Eden + Survivor0 + Survivor1

过程：新对象放在Eden，存活后放进Survivor，每次存活年龄++，最大15岁后进入老年代。

![image-20240518133048816](https://s2.loli.net/2024/09/26/5uOdrHEse8mBhAR.png)

当老年代中空间不足，无法放入新的对象，先尝试minor gc，如果还是不够，就会触发Full GC。Full GC会对整个堆进行垃圾回收。

---

问：JVM垃圾回收算法有哪些

答：

* 标记清除：垃圾回收分为两个节点，分别是标记和清除，效率高，有磁盘碎片，内存不连续
* 标记整理：比清除多了一步整理
* 复制算法：将原有的内存空间一分为二，每次只用其中的一块，正在使用的对象复制到另一个内存空间中，然后将该内存空间清空。交换两个内存的角色。无碎片，但是内存使用率低

---

说一下jvm中的分代回收

 java8中的新生代和老年代：`新生代 : 老年代 = 1 : 3`

![image-20240403121754316](https://s2.loli.net/2024/09/18/Y7GskoEDrPxBiyJ.png)

* 新生的对象都分配到Eden区
* 幸存者区分为from和to。`Eden : from : to = 8 : 1 : 1`

**工作机制**

* 新创建的对象都分配到eden区
* 当eden内存不足，标记eden与from的存活对象
* 将存活的对象采用复制算法复制到to中，to中对象年龄+1，复制完毕后，eden和from得到释放。当年龄超过15，进入老年代。
* survival区不足或者大对象会导致被提前晋升

**MinorGC、MixedGC、FullGC的区别**

* MinorGC也是young GC，发生在新生代的垃圾回收，STW时间短
* Mixed GC：新生代 + 老年代部分区分区域的垃圾回收，G1收集器特有
* Full GC：新生代 + 老年代完整垃圾回收，STW时间长

---

问：说说JVM中的分代回收

答：

1、堆的区域划分
	1）堆被分成了2份，新生代和老年代

​	2）对于新生代，内部又被分为了三个区域。Eden，幸存者的from和to（8 : 1 : 1）

2、对象分代回收的策略

新创建的对象会先分配到eden区，当eden不足时，标记eden和from的存活对象，将存活对象采用复制算法复制到to中，存活的对象年龄+1，复制完毕后，eden和from内存都得到释放。经过一段时间后，eden的内存又出现不足，标记eden和新的from区存活的对象，将其复制到to区，存活的对象年龄+1，当对象的年龄到达15，就会进入老年代。

---

问：为什么分代GC算法要把堆分成年轻代和老年代。

![image-20240518134841920](https://s2.loli.net/2024/09/26/Rz5d9jngQ4C6DEP.png)

---

问：MinorGC、MixedGC、FullGC的区别

* MinorGC也是young GC，发生在新生代的垃圾回收，STW时间短
* Mixed GC：新生代 + 老年代部分区分区域的垃圾回收，G1收集器特有
* Full GC：新生代 + 老年代完整垃圾回收，STW时间长

---

说一下JVM中有哪些垃圾回收期？

在jvm中实现了多种垃圾收集器，有：串行垃圾收集器、并行垃圾收集器、CMS（并发）垃圾收集器、G1垃圾收集器

**串行垃圾收集器**

Serial和Serial Old串行垃圾收集器，是指使用单线程进行垃圾回收，堆内存较小，适合个人电脑

* Serial 作用与新生代，采用复制算法
* Serial Old 作用于老年代，采用标记-整理算法

垃圾回收时，只有一个线程在工作，并且java应用中的所有线程都要STW，等待垃圾回收的完成

![image-20240403123852471](https://s2.loli.net/2024/09/18/RvAVMSI8FJGoPLa.png)

**并行垃圾收集器**

Parallel New 和 Parallel Old是一个**并行**垃圾回收器，JDK8默认使用此垃圾回收器

* Parallel New作用与新生代，采用复制算法
* Parallel Old作用与老年代，采用标记-整理算法

垃圾回收时，多个线程在工作，并且java应用中的所有线程都要STW，等待垃圾回收的完成

![image-20240403124044389](https://s2.loli.net/2024/09/18/fXDdTatB75AsSRI.png)

**CMS（并发）垃圾收集器**

CMS全称Concurrent Mark Sweep，是一款并发的，使用标记-清除算法的垃圾回收期，该回收器是针对老年代垃圾回收的，是一款以获取最短回收停顿时间为目标的收集器，停顿时间短，用户体验良好。其最大特点是在进行垃圾回收是，应用仍然能正常运行。

![image-20240403124623844](https://s2.loli.net/2024/09/18/UCe5NzDBY3Ec9pk.png)

---

问：JVM有哪些垃圾回收器？

答：在jvm中，实现了多种垃圾收集器，包括

* 串行垃圾收集器：Serial GC、 Serial Old GC
* 并行垃圾收集器：Parallel Old GC、ParNew GC
* CMS（并发）垃圾收集器：CMS GC，作用在老年代
* G1垃圾收集器，作用在新生代和老年代

---

问：说说G1垃圾回收器

* 应用于新生代和老年代，在JDK8之后默认使用G1
* 划分成多个区域，每个区域都可以充当eden，survivor，old，humongous。其中humongous专为大对象准备
* 采用复制算法
* 响应时间与吞吐量兼顾
* 分成三个阶段：新生代回收(stw)、并发标记（重新stw）、混合收集
* 如果并发失败（回收速度赶不上创建新对象速度），会触发FullGC

---



## **垃圾回收器的组合关系**

![image-20240518134954046](https://s2.loli.net/2024/09/26/wfpNAMWICuSaq74.png)

---

组合1

**年轻代-Serial垃圾回收器**

<img src="https://s2.loli.net/2024/09/26/YtGVueoNOHQRwEb.png" style="zoom:30%;" />

**老年代-SerialOld垃圾回收器**

<img src="https://s2.loli.net/2024/09/26/nQFavfIwmS1busR.png" alt="image-20240518135313998" style="zoom:30%;" />

---

组合2

**年轻代-ParNew垃圾回收器**（==多线程==回收年轻代的垃圾）

<img src="https://s2.loli.net/2024/09/26/dUvza5pwgRsZDkK.png" alt="image-20240518135633538" style="zoom:30%;" />

**老年代-CMS（Concurrent Mark Sweep）垃圾回收器**（减少SWT对用户线程的影响）

 <img src="https://s2.loli.net/2024/09/26/hp7g3DRrcuiyPMK.png" alt="image-20240518135848820" style="zoom:30%;" />

**cms的执行步骤**

<img src="https://s2.loli.net/2024/09/26/5OrbwApjYceCsmV.png" alt="image-20240518140056199" style="zoom:33%;" />

---

组合3

**年轻代-Parallel Scavenge垃圾回收器**（关注吞吐量）

<img src="https://s2.loli.net/2024/09/26/9LzYCd1EoujbGIx.png" alt="image-20240518140524868" style="zoom:33%;" />

**老年代-Parallel Old垃圾回收器**

<img src="https://s2.loli.net/2024/09/26/PecWYpRyaFKOrIz.png" alt="image-20240518140654735" style="zoom:33%;" />

---

==**G1**==

<img src="https://s2.loli.net/2024/09/26/3Sq1HsjQrkivwRZ.png" alt="image-20240518141622339" style="zoom:33%;" />

G1出现之前的内存结构：

<img src="https://s2.loli.net/2024/09/26/z1okE49T3A5puhc.png" alt="image-20240518141748988" style="zoom:33%;" />

G1的内存结构：

<img src="https://s2.loli.net/2024/09/26/CM1uwy687HGh5Nz.png" alt="image-20240518141820904" style="zoom:33%;" />

G1垃圾回收器有两种方式：年轻代回收(Young GC)和混合回收(Mixed GC)

Young GC：回收Eden和Survivor区中不用的对象，会导致STW，可以通过参数`-XX:MaxGCPauseMillis=n`(默认200)设置每次垃圾回收时的最大暂停时间毫秒数，G1垃圾回收器会尽可能地2保证暂停时间。

1、新创建的对象会存放在Eden区，当G1判断年轻代区不足（max默认60%），无法分配对象时会执行Young GC

2、标记出Eden和Survivor区域中存活的对象

3、根据配置的最大暂停时间选择某些区域将存活对象复制到一个新的Survivor区中（年龄+1），清空这些区域



<img src="https://s2.loli.net/2024/09/26/rZaWvsnh9F73R2J.png" alt="image-20240518142459367" style="zoom:33%;" />

4、后续Young GC与之前的相同，只不过Survivor区中存活对象会被搬运到另一个Survivor区

5、当某个存活对象的年龄达到阈值，就会被放入老年代

6、部分对象如果大小超过Region的一般，会直接放入老年代，这类老年被称为Humongous区。比如堆内存4G，每个Region是2M，只要一个大对象超过了1M就被放入 区，如果对象过大会横跨多个Region。

7、多次回收之后，会出现很多Old老年代区，此时总堆占有率达到阈值时，会触发混合回收Mixed GC（默认45%），回收所有年轻代和部分老年代的对象以及大对象区。采用复制算法完成。

MixGC:

<img src="https://s2.loli.net/2024/09/26/Aztr3heCKNGHx52.png" alt="image-20240518143314320" style="zoom: 33%;" />

<img src="https://s2.loli.net/2024/09/26/gWsxtDNzSiVyuTK.png" alt="image-20240518143503882" style="zoom:33%;" />

<img src="https://s2.loli.net/2024/09/26/BmIA3bkVgn7S8HJ.png" alt="image-20240518143531142" style="zoom:33%;" />

小结：

![image-20240518143638870](https://s2.loli.net/2024/09/26/cVZLRrXqlGuDkEs.png)



---

强引用、软引用、弱引用、虚引用的区别

**1、强引用**

垃圾回收期不能回收被强引用的对象

![image-20240403134903527](https://s2.loli.net/2024/09/18/B2skXpjcRiyvx6U.png)

**2、软引用**

一个对象只被弱引用，在垃圾回收一开始不会回收，内存不足时再次触发垃圾回收，才会被回收

![image-20240403134953443](https://s2.loli.net/2024/09/18/VHAZjzUvMaPg94u.png)

**3、弱引用**

一个对象只被弱引用时，只要触发垃圾回收了，就直接回收

![image-20240403135212093](https://s2.loli.net/2024/09/18/vu1zGHfVbxOYogA.png)

**4、虚引用**

必须配合引用队列使用，被引用对象回收时，会将虚引用入队，由`Reference Handler`线程调用虚引用相关的方法释放相关的**直接**内存

![image-20240403135937421](https://s2.loli.net/2024/09/18/XYLiewaKfMcupTO.png)

---

问：强引用、软引用、弱引用、虚引用的区别

* 强：只要沿着GC Roots能找到，就不会被回收
* 软：需要配合`SoftReference`使用，当垃圾多次回收，内存依然不够的时候会回收
* 弱：需要配合`WeakReference`使用，只要进行了垃圾回收，就会把弱引用对象回收
* 虚：必须配合引用队列使用，被引用对象回收时，会将虚引用入队，由`Reference Handler`线程调用虚引用相关方法释放直接内存
