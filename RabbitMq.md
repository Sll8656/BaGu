## 消息可靠性

> **如何保证消息可靠性？**

![image-20240920145221843](https://s2.loli.net/2024/09/20/rQHPpKXOUsivY5h.png)

三个层面：

1. 消息没有到达 mq：生产者确认机制，mq收到消息会给publisher发送ack。
2. 消息在mq中丢失：队列持久化、交换机持久化、消息持久化
3. 消费者没接受到消息：
   1. 消费者确认机制，消费者消费完消息给mq发送确认。
   2. 失败重试机制：消费出现异常会重试，次数到达上限后，消息被投递进异常交换机，由人工处理。



## 消息重复消费

> **如何保证消息不被重复消费？**

幂等性设计：

**使用唯一标识符**：为每条消息分配一个唯一的 ID（如 UUID），消费者在处理消息前检查该 ID 是否已处理过。如果已处理，则跳过处理。

**记录已处理的消息**：使用数据库或缓存（如 Redis）存储已处理的消息 ID。处理前先查询记录，确保不重复处理。



## 死信交换机（延迟队列）

> 说说mq的死信交换机

**延迟队列的场景**：超时订单自动取消、限时优惠、内容审核、定时发布（选时间发朋友圈）

**==延迟队列 = 死信交换机 + ttl==**

![image-20240920152405328](https://s2.loli.net/2024/09/20/LVgcN9DAbUi4B5S.png)

普通队列中的消息超时 ->进入死信交换机，然后消费死信交换机的即可。



## 消息堆积

> 消息堆积怎么解决

1. 增加消费者的数量

2. 提高消费者的消费效率：使用线程池

3. 限制生产者的速率

4. 扩大队列容积：使用惰性队列（接收到消息直接存入磁盘）

   ```java
   public Queue lazeQueue() {
     return QueueBuilder.durable("lazy.queue").lazy().build();
   }
   ```



## 高可用

> 如何保证rabbitmq的高可用

使用镜像队列：镜像队列类似于redis的集群，一主多从。主宕机后，镜像结点会替代成新的主。



