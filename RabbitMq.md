## 使用

publicser `->exchange ->queue-> `consumer

topicExchange通过routingkey和queue进行绑定，发送消息的时候就给他指定routingkey和topicExchange，然后topicExchange根据routingkey将这个消息发送到通过routingkey绑定的队列。

publicsher只用routingkey发送到交换机，与队列无关。consumer只和队列通信，与routingkey和交换机无关。

---

1. 交换机将消息路由到多个队列：
   交换机（Exchange） 可以根据其类型（如 Direct、Topic、Fanout 等）以及消息的路由键，将一条消息路由到一个或多个队列。
   如果有多个队列绑定到同一个交换机，并且它们符合消息的路由规则（例如使用相同的路由键或匹配的路由模式），那么**这条消息会被复制并发送**到所有符合条件的队列。

2. 队列中的消息只能被消费一次：
   队列（Queue） 是一个消息的存储容器，每条消息只能在队列中被消费一次。一旦消费者成功消费了消息，这条消息会从队列中删除，不再提供给其他消费者。
   如果有多个消费者同时监听同一个队列，每条消息只会被其中一个消费者消费。这是 RabbitMQ 保证消息的至少一次消费（At-least-once Delivery）的方式。

---

**@RabbitListener** 可以同时监听多个队列。可以通过配置 @RabbitListener 注解的 queues 属性来指定一个或多个队列。当这些队列中的任何一个接收到消息时，@RabbitListener 标注的方法都会被触发来处理消息。

**@RabbitListener(queues = {"queue1", "queue2"})**：这里指定了两个队列 queue1 和 queue2。当这两个队列中的任意一个收到消息时，方法都会被触发。

---

## 模板代码：

```java
//消息发送
public void send() {
  //...
  rabbitTemplate.convertAndSend(
                "交换机名称",
                "routingKey",
                "消息内容（封装类型）");
}
// 监听事件
@RabbitListener(bindings = @QueueBinding(
        value = @Queue(name = "队列名", durable = "true"),
        exchange = @Exchange(name = "交换机名称", type = ExchangeTypes.TOPIC),
        key = "routingKey"
))
public void listenSignInMessage(Object message){
} 
```

解释：

1. 监听事件的@RabbitListener是负责==声明==交换机、routingkey、队列的。并且声明完成后，自己会监听这个==队列==。
2. 发送消息，指定交换机、routingKey、消息内容。其中消息内容可以是封装的实体类。接收的时候也用这个实体类接收即可

---

mq是异步的，rpc是同步的。

mq通常来说不会在同一个模块,但是也可以在一个模块。

注意：如果使用消息转换器序列化实体类，则：

1. 实体类需要提供构造方法，
2. publisher和listener都要配置消息转换器，使用jackson的



## 消息可靠性

> **如何保证消息可靠性？**

![image-20240920145221843](https://s2.loli.net/2024/09/20/rQHPpKXOUsivY5h.png)

三个层面：

1. 消息没有到达 mq：开启生产者确认机制（confirm），只要消息成功发送到交换机之后，RabbitMQ就会发送一个ack给生产者（即使消息没有Queue接收，也会发送ack）。如果消息没有成功发送到交换机，就会发送一条nack消息，提示发送失败。异步，性能好。

2. 消息在mq中丢失：队列持久化、交换机持久化、消息持久化（`delivery mode`为2）

3. 消费者没接受到消息：

   1. 消费者确认机制，消费 者消费完消息给mq发送确认。

   2. 失败重试机制：消费出现异常会重试，次数到达上限后，消息被投递进异常交换机，由人工处理。



## 消息有序性

**一对一：**拆分queue，使得一个queue只对应一个消费者

​	由于MQ一般都能保证**内部队列是先进先出的**，所以把需要保持先后顺序的一组消息使用某种算法都分配到同一个消息队列中。然后只用一个消费者单线程去消费该队列，这样就能保证消费者是按照顺序进行消费的了。

​	但是消费者的吞吐量会出现瓶颈。如果多个消费者同时消费一个队列，还是可能会出现顺序错乱的情况，这就相当于是多线程消费了。

**重试机制：**

​	对于多线程的消费同一个队列的情况，可以使用重试机制；

​	比如有一个微博业务场景的操作，发微博、写评论、删除微博，这三个异步操作，如果一个消费者先执行了写评论的操作，但是这时微博都还没发，写评论一定是失败的，等一段时间。等另一个消费者，先执行发微博的操作后，再执行，就可以成功







## 消息重复消费

> **如何保证消息不被重复消费？**

消息重复的原因有两个：1.生产时消息重复，2.消费时消息重复。

​	生产者发送消息给MQ，在MQ确认的时候出现了网络波动，生产者没有收到确认，这时候生产者就会重新发送这条消息，导致MQ会接收到重复消息。

​	消费者消费成功后，给MQ确认的时候出现了网络波动，MQ没有接收到确认，为了保证消息不丢失，MQ就会继续给消费者投递之前的消息。这时候消费者就接收到了两条一样的消息。

**解决方法**：

​	发送消息时让每个消息携带一个**全局的唯一ID**，在消费消息时先判断消息是否已经被消费过，保证消息消费逻辑的幂等性。

例如引入数据库或者redis：

* 数据库唯一主键去重：主键是不能冲突的，重复的数据无法插入

* 引入Redis解决重复消费问题

  * 利用Redis，首先系统生成全局唯一的 id，用set操作放入Redis中

  * 如订单信息id，消费后存储在Redis中，如果下次再来，先查看Redis中是否存在

  * 如果存在，即此消息已经被消费过（后续不做消费处理）

  * 如果不存在，即未消费，此时再将此id存入Redis中，进行后续的逻辑操作

综上，消费过程为：

1. 消费者获取到消息后先根据id去查询 redis/db 是否存在该消息

2. 如果不存在，则正常消费，消费完毕后写入redis/db

3. 如果存在，则证明消息被消费过，直接丢弃



## 死信交换机（延迟队列）

> 说说mq的死信交换机

**延迟队列的场景**：超时订单自动取消、限时优惠、内容审核、定时发布（选时间发朋友圈）

**==延迟队列 = 死信交换机 + ttl==**

消息消费失败的原因：

- 消息被拒绝并且消息没有重新入队（requeue=false）
- 消息超时未消费
- 达到最大队列长度

当普通队列中有死信时，RabbitMQ 就会自动的将这个消息**重新发布到设置的死信交换机**去，然后被路由到死信队列。可以监听死信队列中的消息做相应的处理。

![image-20240920152405328](https://s2.loli.net/2024/09/20/LVgcN9DAbUi4B5S.png)

普通队列中的消息超时 ->进入死信交换机，然后消费死信交换机的即可。

## 消息堆积

> 消息堆积怎么解决

1. 增加消费者的数量

2. 提高消费者的消费效率：使用线程池

3. 限制生产者的速率

4. 扩大队列容积：使用惰性队列（接收到消息直接存入磁盘）

   ```java
   public Queue lazeQueue() {
     return QueueBuilder.durable("lazy.queue").lazy().build();
   }
   ```

导致消息积压突然增加，最粗粒度的原因，只有两种：

1. 发送变快了

2. 消费变慢了。

要解决积压的问题：

1. 可以通过 扩容消费端的实例数来提升总体的消费能力。

2. 如果短时间内没有足够的服务器资源进行扩容，那么就将系统降级，通过关闭一些不重要的业务，减少发送方发送的数据量，最低限度让系统还能正常运转，服务一些重要业务。





## 高可用

> 如何保证rabbitmq的高可用

使用镜像队列：镜像队列类似于redis的集群，一主多从。主宕机后，镜像结点会替代成新的主。



## Channel 概念

​	信道是生产消费者与rabbit通信的渠道，生产者publish或者消费者消费一个队列都是需要通过信道来通信的。信道是建立在TCP上面的虚拟链接，也就是rabbitMQ在一个TCP上面建立成百上千的信道来达到多个线程处理。**注意是一个TCP 被多个线程共享，每个线程对应一个信道，信道在rabbit都有唯一的ID，保证了信道的私有性，对应上唯一的线程使用。**

==为什么RabbitMQ 需要信道，如果直接进行TCP通信呢？==

关键点：复用TCP连接

上述的描述其实已经很明显了，因为TCP可以被多个线程共享，显然线程比TCP要省事的多。

TCP的创建开销很大，创建需要三次握手，销毁需要四次握手。

如果不使用信道，那么引用程序就会使用TCP方式进行连接到RabbitMQ，因为MQ可能每秒会进行成千上万的链接，

总之就是TCP消耗资源，TCP链接可以容纳无限的信道，不会有并发上面的性能瓶颈。



在代码中并不会有直观的能看到信道这个概念。

因为代码中都是用自动配置。

```java
@Autowired
private RabbitTemplate rabbitTemplate; 
或者
@Autowired
private AmqpTemplate template;
```

都是自动隐藏了详细的建立连接过程。

但是在使用rabbitmq时不管是消费还是生产都需要创建信道（channel） 和connection（连接）。

连接是连接到RabbitMQ的服务器。

示意图：

![image-20240925173656193](https://s2.loli.net/2024/09/25/eh9xUM426RyFrHS.png)

看这个示意图的话，我们好像可以直接使用Connection就可以完成信道的工作。

但是因为建立连接会很耗费性能，这也是有点类似于工厂模式那种吧~用类似nio的做法，tcp连接复用，当每个信道的流量不是很大时，复用。但是当流量很大的时候，多个信道用一个connection就会出现性能的瓶颈。所以使用多个connection也是合理的，这样信道可以平摊到每个connection中。具体调节方式需要在业务中进行体验。

