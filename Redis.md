# 基础篇

### 什么是Redis？

Redis是一个基于c语言开发的NoSQL数据库，数据是保存在内存中的，因此读写非常快。

他还广泛应用于分布式方向，并且数据是以key-value的形式存储。



### 为什么要用Redis/缓存？

高性能：

从硬盘中读取数据相比于内存来说特别慢，所以把高频访问的数据放入缓存中，能大大提高效率。

高并发：

使用Redis缓存之后的QPS(每秒查询次数)远大于仅仅只用MySQL数据库。

直接操作缓存能够承受的数据库请求数 远远大于直接访问数据。所以将一部分数据放入缓存中，用户部分请求就不会经过数据库，能提高系统总体并发。

### Redis为什么这么快？

因为Redis内部做了很多性能优化。

1、Redis基于内存，访问速度比外存快太多了。

2、Redis基于Reactor模式设计了一套高效的事件处理模型，主要是**单线程事件循环和IO多路复用**。

3、Redis内置了很多优化后的数据结构，性能高。



### 分布式缓存常见的技术选型方案有哪些？

Memcached和Redis。

Memcached是分布式刚兴起时候较常用，后来因为Redis太强大、好用，大家逐渐都开始使用Redis了。

腾讯也开源了一款类似于Redis的高性能KV存储数据库，叫做Tendis。

但是Tendis开源版本已经没有维护更新了，所以不建议使用。



### 讲一讲Redis和Memcached的异同点？

**共同点：**

1.都基于内存，当做缓存使用。

2.都有过期策略。

3.两者性能都很高。





**区别：**

思路：从章节来回答：

数据类型 ->持久化 -> 集群 ->消息队列

1.Redis数据类型更加丰富，有list,set,zset,hash等，支持复杂的应用场景。而Memcached只有最简单的K-V(map)结构。

2.Redis支持数据持久化，可以将内存数据持久化到磁盘当中，而Memcached的数据全部在内存当中。

3.Redis有灾难恢复机制，因为他可以持久化、备份数据。



4.Redis在服务器内存要耗尽时，能够将不用的数据放入磁盘，缓解内存压力。Memcached在服务内存用完后直接报异常。

5.Redis支持集群，Memcached没有原生的集群。

6.Redis是单线程的，多路IO复用模型。Memcached是多线程，非阻塞IO复用的模型。

7.Redis支持发布订阅模式、Lua脚本、事务等功能，Memcached不支持。



通过以上区别可以发现，Redis强于Memcached。



### (待解决)常见的缓存读写策略有哪些？

https://javaguide.cn/database/redis/3-commonly-used-cache-read-and-write-strategies.html





# 应用篇

### Redis只能做缓存吗？

Redis还可做分布式锁、限流、消息队列、延时队列、分布式Session。

分布式锁：基于Redisson来实现分布式锁。

限流：一般通过Redis + Lua脚本来实现限流。

消息队列：Redis自带的List数据结构可以作为一个简单的队列使用。

分布式Session：利用String或者Hash类型保存Session数据，所有的服务器都可以访问。





### （待解决）如何使用Redis做分布式锁？

进入分布式锁那一章节







# 数据类型篇

### 列举一下Redis常用的数据类型？

5种基础类型：String, List, Set , Hash, Zset(有序集合)

3种特殊类型：HyperLogLog 、 BitMap、 Geospatial





## String

### String的应用场景有哪些？

String是Redis中最简单同时也是最常用的一个数据类型，他是二进制安全的，能够用来存储任何类型的数据，比如字符串、图片、序列化后的对象。

常见应用场景如下：

* String可以用来记录Session、Token、序列化后的对象、图片   的缓存
* String可以用来计数，比如用户单位时间的请求数、页面单位时间的访问数
* 分布式锁，利用setnx key value  命令能够实现一个最简单的分布式锁



### String底层实现是什么？

Redis是用C语言编写的，但是Redis的Sring类型不是C语言的字符串，而是自己编写了SDS来作为底层实现。

**SDS：**

1.SDS获取长度时间复杂度为O(1)。因为SDS结构中使用len属性记录了字符串长度。

2.SDS是二进制安全的。C语言字符串以\0结尾，而一些二进制文件中就可能包括这种空字符，所以C字符串无法正确保存。而SDS使用len属性来判断是否结束，所以不存在这个问题。

3.SDS可以避免缓冲区溢出。拼接字符串不会造成缓冲区溢出。因为SDS在拼接之前会检查空间够不够，不够就会扩容。





### 存储对象数据用String还是Hash？

String存放的是序列化后的对象数据，存放的是整个对象。Hash是对对象的每个字段单独存储。如果对象中某些字段要经常变动或者经常需要单独别字段，Hash更加适合。

String更节省内存，并且存储具有多层嵌套的对象也会方便很多。

绝大部分情况用String就行了。



### 存储购物车信息使用String还是Hash？

由于购物车中的商品会频繁修改和变更，所以应该使用Hash存储购物车信息。

我们记录用户id为key，商品id为field，数量为value。

则维护购物车信息就可以使用下面的操作：

* 用户添加商品就是往Hash里面增加新的field和value
* 查询购物车信息就是遍历对应的Hash
* 更改商品数量就是修改value
* 删除商品就是删除field
* 清空购物车直接删除对应的key



### 如何使用Redis实现一个排行榜？

使用Sorted Set数据类型。



## Set

### Set的应用场景是什么？

Redis中的set是无序集合，集合中的元素没有顺序但是是唯一的。

应用场景如下：

* 存放数据不能重复的场景，比如文章的点赞功能。
* 需要获取多个数据源交集并集差集的场景：如共同好友、共同粉丝、共同关注、推荐好友、推荐音乐、订阅号推荐等。
* 需要随机获取数据源中元素的场景：比如抽奖系统、随机点名等。



### 如何使用Set实现抽奖系统？

实现简单的抽奖系统，使用下面三个命令：

* `SADD key member1 member2`：向指定集合添加一个或多个元素
* `SPOP key count`：随机移除并获取指定集合中的一个或多个元素，适合不允许重复中奖的场景。
* `SRANDMEMBER key count`：随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。



### 如何使用Bitmap统计活跃用户？

Bitmap存储的是连续的二进制数字，通过Bitmap，只需要一个比特位来表示某个元素的值和状态，key就是对应元素本身。

我们可以将Bitmap看成只存储1和0的数组，元素下标就叫做offset。

如果想使用Bitmap统计活跃用户，可以使用日期作为key，然后用户ID为offset，如果当天活跃过就置为1。



## 三大问题



### 什么缓存穿透？

缓存穿透是大量请求的key 都是不合理的，这些key根本不在缓存中，也不在数据库中。导致这些大量请求直接打到了数据库，可能导致数据库宕机。



### 缓存穿透的解决办法？

首先做好参数校验，让不合法的参数直接抛出异常信息给客户端。比如数据库表中id不能小于0、传入邮箱格式不对。

1）缓存无效的key

如果缓存和MySQL都查不到某个key，就将这个key写入Redis中并设置过期时间。应对请求变化不频繁的情况。

2）布隆过滤器

布隆过滤器是一种数据结构，可以判断一个给定的数据是否存在于海量的数据中。

做法：将所有可能存在的请求的值都放在布隆过滤器中，当用户请求过来的时候，先判断发生请求的值在不在布隆过滤器中。不在就直接报错。

布隆过滤器可能会误判。他说某个元素存在，有可能不存在。但是如果说某个元素不存在，就一定不存在。

因为原理是使用hashcode，如果两个字符串出现hash值一样的情况。a不在，b在，但是a和b的hashcode一致。查a的时候，会根据hashcode查，发现a在。所以他会说a存在，但是实际上a不存在。

布隆过滤器的更多原理去看guide。



### 什么是缓存击穿？

请求的key对应的是热点数据，这份数据存在数据库中，但是不在缓存中（通常因为缓存中的数据过期）。这就导致瞬间大量的key打到了数据库上，可能使数据库宕机。

场景：秒杀的时候，缓存中商品的key突然过期。于是大量请求直接打到了数据库。

<img src="./assets/image-20231219201537681.png" style="zoom:50%;" />



### 缓存击穿的解决办法？

* 设置热点数据永不过期，或者过期时间较长
* 针对热点数据提前预热，确保存进缓存并且在秒杀结束前都不会过期。
* 请求数据库写数据到缓存之前要先获取互斥锁，保证只有一个请求打到数据库，减少数据库压力。
* 设置互斥锁，让线程查不到就等待一会，而不是立马去在数据库上重建缓存<img src="./assets/image-20231219201717510.png" style="zoom:33%;" />



### 击穿和穿透的区别？

击穿：key是热点数据，并且存在于数据库中，不存在与缓存中（通常因为缓存中的数据过期）

穿透：key既不存在与缓存，也不存在于数据库。



### 什么是缓存雪崩？

缓存在同一时间，大面积失效，导致大量的请求都直接落在数据库上，对数据库造成巨大压力。

缓存服务宕机也会导致缓存雪崩。





### 缓存雪崩的解决办法？

**针对Redis服务不可用的情况：**

* 采用Redis集群，避免单机出现故障导致整个缓存服务无法使用
* 限流，避免同时处理大量的请求

**针对热点缓存失效的情况：**

* 设置不同的失效时间，比如随机设置缓存的失效时间
* 设置二级缓存
* 设置缓存永远不失效（实用性太差）



### 雪崩和击穿的区别？

导致缓存雪崩的原因是缓存中的**大量数据**失效。

导师缓存击穿的原因是**某一个热点数据**不在缓存中（通常是因为缓存中的那份数据过期）。



小结：

Key不存在：穿透

少量热点key失效：击穿

大量key失效：雪崩





# 分布式篇

## 说说缓存更新策略

缓存更新是用于解决Redis内存不足的问题：

![image-20231219162201029](./assets/image-20231219162201029.png)

使用主动更新策略最好。

而主动更新中，有三种模式：

Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案

Read/Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理

Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致

**综合考虑使用方案一**，但是方案一调用者如何处理呢？这里有几个问题



操作缓存和数据库时有三个问题需要考虑：

1、删除缓存还是更新缓存？

 *	更新缓存，每次更新数据库都更新缓存，无效写操作太多。
 *	删除缓存：更新数据库时让缓存失效，查询时再更新缓存。

2、如何保证缓存与数据库的操作的同时成功或失败？

* 单体系统，将缓存与数据库操作放在一个事务
* 分布式系统，利用TTC等分布式事务方案



3、先操作缓存还是先删数据库：

![image-20231219161333638](./assets/image-20231219161333638.png)

前置知识：更新数据库操作速度慢，操作缓存速度快。

先删除缓存，再操作数据库：更新数据库慢，所以容易被别的线程见缝插针

先操作数据库，再删除缓存：写入缓存快，并且更新数据库满。别的线程难以插入操作缓存的方法之间。

因此先操作数据库比先删除缓存更好！





总结：

<img src="./assets/image-20231219163701051.png" style="zoom:50%;" />
